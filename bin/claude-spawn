#!/usr/bin/env node

/**
 * Claude Code Spawn CLI Tool
 * Command-line interface for claude-code-spawn
 */

const { runClaude, runCommand, testSimpleCommand, getRecentSessions, viewLog } = require('../index');
const path = require('path');

function printUsage() {
  console.log(`
Claude Code Spawn CLI

Usage:
  claude-spawn [options] "<prompt>"
  claude-spawn --test
  claude-spawn logs [options]
  claude-spawn --help

Options:
  --fire-and-forget    Run in background mode
  --timeout <ms>       Set timeout in milliseconds
  --cwd <path>         Set working directory
  --no-permissions     Skip permission prompts
  --quiet              Minimal output
  --save-log           Save execution logs to file
  --log-dir <path>     Directory for logs (default: ./claude-spawn-logs)
  --test               Run test suite
  --version            Show version
  --help               Show this help

Log Commands:
  claude-spawn logs                List recent sessions
  claude-spawn logs <session-id>   View specific session log

Examples:
  claude-spawn "What is 2+2?"
  claude-spawn --fire-and-forget "Analyze this project"
  claude-spawn --save-log "Debug this code"
  claude-spawn --timeout 30000 "Complex analysis task"
  claude-spawn --cwd ./project "Improve the code here"
  claude-spawn logs
  claude-spawn logs 1737456789-12345
  claude-spawn --test

Environment:
  CLAUDE_SPAWN_TIMEOUT    Default timeout (ms)
  CLAUDE_SPAWN_QUIET      Set to '1' for quiet mode
`);
}

function printVersion() {
  const packageJson = require('../package.json');
  console.log(`claude-spawn v${packageJson.version}`);
}

async function main() {
  const args = process.argv.slice(2);
  
  if (args.length === 0) {
    printUsage();
    process.exit(1);
  }

  // Parse arguments
  const options = {
    fireAndForget: false,
    timeout: parseInt(process.env.CLAUDE_SPAWN_TIMEOUT) || null,
    cwd: process.cwd(),
    dangerouslySkipPermissions: true,
    logging: process.env.CLAUDE_SPAWN_QUIET !== '1',
    saveLog: false,
    logDir: null
  };

  let prompt = '';
  let i = 0;

  // Handle logs command
  if (args[0] === 'logs') {
    try {
      if (args[1]) {
        // View specific session
        const logs = await viewLog(args[1], options.logDir);
        console.log(`\nSession: ${args[1]}\n`);
        
        for (const entry of logs) {
          switch (entry.type) {
            case 'session_start':
              console.log(`[${entry.timestamp}] Started: ${entry.command} ${entry.args.join(' ')}`);
              console.log(`  Working directory: ${entry.cwd}`);
              break;
            case 'stdout':
              if (entry.data.trim()) {
                console.log(`[STDOUT] ${entry.data.trim()}`);
              }
              break;
            case 'stderr':
              if (entry.data.trim()) {
                console.error(`[STDERR] ${entry.data.trim()}`);
              }
              break;
            case 'error':
              console.error(`[ERROR] ${entry.message}`);
              break;
            case 'session_end':
              console.log(`[${entry.timestamp}] Ended: code=${entry.code}, duration=${entry.duration}ms`);
              break;
          }
        }
      } else {
        // List recent sessions
        const sessions = await getRecentSessions(options.logDir, 20);
        
        if (sessions.length === 0) {
          console.log('No sessions found');
        } else {
          console.log('Recent sessions:\n');
          for (const session of sessions) {
            console.log(`${session.sessionId}`);
            console.log(`  Command: ${session.command} ${session.args.join(' ')}`);
            console.log(`  Time: ${session.timestamp}`);
            console.log('');
          }
          console.log(`\nTo view a session: claude-spawn logs <session-id>`);
        }
      }
      process.exit(0);
    } catch (error) {
      console.error('Error:', error.message);
      process.exit(1);
    }
  }

  while (i < args.length) {
    const arg = args[i];

    switch (arg) {
      case '--help':
      case '-h':
        printUsage();
        process.exit(0);
        break;

      case '--version':
      case '-v':
        printVersion();
        process.exit(0);
        break;

      case '--test':
        console.log('Running test suite...\n');
        try {
          const results = await testSimpleCommand({ logging: true });
          
          const passed = Object.values(results).filter(r => r.success).length;
          const total = Object.keys(results).length;
          
          console.log(`\nTest Results: ${passed}/${total} passed`);
          
          if (passed === total) {
            console.log('✅ All tests passed!');
            process.exit(0);
          } else {
            console.log('❌ Some tests failed');
            process.exit(1);
          }
        } catch (error) {
          console.error('Test suite failed:', error.message);
          process.exit(1);
        }
        break;

      case '--fire-and-forget':
        options.fireAndForget = true;
        break;

      case '--timeout':
        i++;
        if (i >= args.length) {
          console.error('Error: --timeout requires a value');
          process.exit(1);
        }
        options.timeout = parseInt(args[i]);
        if (isNaN(options.timeout)) {
          console.error('Error: timeout must be a number');
          process.exit(1);
        }
        break;

      case '--cwd':
        i++;
        if (i >= args.length) {
          console.error('Error: --cwd requires a path');
          process.exit(1);
        }
        options.cwd = path.resolve(args[i]);
        break;

      case '--no-permissions':
        options.dangerouslySkipPermissions = false;
        break;

      case '--quiet':
        options.logging = false;
        break;

      case '--save-log':
        options.saveLog = true;
        break;

      case '--log-dir':
        i++;
        if (i >= args.length) {
          console.error('Error: --log-dir requires a path');
          process.exit(1);
        }
        options.logDir = path.resolve(args[i]);
        break;

      default:
        if (arg.startsWith('-')) {
          console.error(`Error: Unknown option ${arg}`);
          process.exit(1);
        }
        prompt = arg;
        break;
    }
    i++;
  }

  if (!prompt) {
    console.error('Error: No prompt provided');
    printUsage();
    process.exit(1);
  }

  // Execute Claude
  try {
    if (options.logging) {
      console.log('🤖 Starting Claude...');
      if (options.fireAndForget) {
        console.log('   Mode: Fire-and-forget (background)');
      }
      if (options.timeout) {
        console.log(`   Timeout: ${options.timeout}ms`);
      }
      console.log(`   Working directory: ${options.cwd}`);
      console.log('');
    }

    const result = await runClaude(prompt, options);

    if (options.fireAndForget) {
      if (options.logging) {
        console.log('✅ Claude started in background');
        console.log(`   Process ID: ${result.pid}`);
        console.log('   You can continue with other work');
      }
    } else {
      if (options.logging) {
        console.log('✅ Claude completed successfully');
        if (options.saveLog && result.sessionId) {
          console.log(`   Session ID: ${result.sessionId}`);
          console.log(`   Log file: ${result.logFile}`);
        }
        console.log('\n--- Response ---');
      }
      console.log(result.stdout);
    }

  } catch (error) {
    console.error('❌ Claude execution failed:');
    console.error('  ', error.message);

    if (error.message.includes('Credit balance')) {
      console.error('\n💡 Tip: This error often occurs when running inside Claude Code environment');
      console.error('   Try running from a regular terminal or deploy to a server');
    }

    if (error.message.includes('Command not found')) {
      console.error('\n💡 Tip: Make sure Claude CLI is installed:');
      console.error('   npm install -g @anthropic-ai/claude-code');
    }

    process.exit(1);
  }
}

// Handle uncaught errors gracefully
process.on('uncaughtException', (error) => {
  console.error('Unexpected error:', error.message);
  process.exit(1);
});

process.on('unhandledRejection', (error) => {
  console.error('Unhandled promise rejection:', error.message);
  process.exit(1);
});

// Run the CLI
main().catch((error) => {
  console.error('CLI error:', error.message);
  process.exit(1);
});